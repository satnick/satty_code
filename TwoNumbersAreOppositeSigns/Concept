Numbers a and b are opposite signs can be checked using bitwise xor operator.
Negative number is represented as, lets say -3
To represent -3, first find the bit of 3
3 => 00000000000000000000000000000011
  Invert all the bits => 11111111111111111111111111111100
  Add 1 to inverted bits which will represent -3 = 11111111111111111111111111111101

So -3 => 11111111111111111111111111111101

So negative number has 1 in the 32nd bit always.

If number are of opposite signs, then positive number will have 0 at 32nd bit i.e. at 31st place indexing from 0
3 => 00000000000000000000000000000011
-3=> 11111111111111111111111111111101

If XOR of -3 and 3 is done, then 32nd bit will be 1 
3 ^ -3 => 
00000000000000000000000000000011 ^ 11111111111111111111111111111101 => 11111111111111111111111111111110

So 32nd bit is 1, and we know negative number has 1 in 32nd bit
so xor of positive and negative number is always negative.

To check it in code.

bool isOpposite(int a, int b)
{
  int res = a^b;

  if(res < 0) //Since xor will have 32nd bit as 1 if both are opposite
  {
    cout<<"Numbers are of opposite signs";
  }
  else
  {
    cout << "Numbers are same signs";
    return false;
  }
}



bool isOpposite(int a, int b)
{
  int res = a^b;

  if(res >> 31) //Since xor will have 32nd bit as 1 if both are opposite, so right shift 31 times to check its 1
  {
    cout<<"Numbers are of opposite signs";
    return true;
  }

  else
  {
    cout << "Numbers are same signs";
    return false;
  }
}
  
